package Evaluation;

import help.ArrayPrinter;
import help.MinMaxAvgEvaluator;
import help.Printer;
import help.ProgressPrinter;
import main.InputGenerator;
import main.Main;
import main.PartitionSolver;
import main.Solution;

import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Comparator;

import static help.ArrayHelp.cast;
import static help.ArrayHelp.fill;
import static help.ArrayPrinter.getNeededDigits;
import static help.ArrayPrinter.printArrayWithDecimalPoint;
import static help.MathHelp.binomialK;
import static help.MathHelp.nChooseK;
import static help.Printer.printf;
import static help.Printer.println;
import static help.Printer.setPrintToConsole;
import static help.Printer.startFilePrinting;
import static help.Printer.stopWritingToFile;
import static main.InputGenerator.generateInput;
import static main.Main.calculateMinMax;
import static main.Main.printDistribution;

public class BinomialTesting {
    private static final String path = Paths.get("").toAbsolutePath() + "\\src\\main\\java\\textFiles\\autoGeneratedResults\\other\\binomialResults\\";
    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd_MM-HH_mm");

    public static void testMultipleRandomBinomialWithSolution() {
        double[] p = new double[]{0.1, 0.5, 0.1, 0.5, 0.25};
        int count = p.length;
        long[] ms = new long[]{100, 100, 50, 50, 50};
        long[] ns = fill(count, (i) -> 10000);
        long[] ks = fill(count, (i) -> 10000);
        testMultipleRandomBinomialWithSolution(ms, ns, p, ks);
    }

    public static void testMultipleRandomBinomialWithSolution(long m, long n, long k) {
        double[] p = new double[]{0.1, 0.25, 0.5, 0.75, 0.9};
        int count = p.length;
        long[] ms = fill(count, (i) -> m);
        long[] ns = fill(count, (i) -> n);
        long[] ks = fill(count, (i) -> k);
        testMultipleRandomBinomialWithSolution(ms, ns, p, ks);
    }

    private static void testMultipleRandomBinomialWithSolution(long[] m, long[] n, double[] p, long[] k) {
        startFilePrinting(path + formatter.format(LocalDateTime.now()) + "_difFromExpectation");
        for (int i = 0; i < m.length; ++i) {
            testRandomBinomialPartition(m[i], n[i], p[i], k[i]);
            println("------------------------------------------------------------------------");
        }
        stopWritingToFile();
    }

    public static void researchBinomialInput(int T) {
        int expected = (int) Math.round(Main.DEFAULT_P_BINOMIAL * Main.DEFAULT_N);
        long sum = 0;
        long sumAbs = 0;
        int intervallLength = 200;
        long[] counts = new long[12000 / intervallLength];
        int t;
        for (t = 0; t < T && !Thread.interrupted(); ++t) {
            long[] input = generateInput(7, 10 * 1000);
            for (int i = 0; i < input.length; ++i) {
                input[i] -= expected;
            }
            long temp = Arrays.stream(input).sum();
            System.out.printf("%d;%d%n", t, temp);
            int abs = (int) Math.abs(temp);
            sum += temp;
            sumAbs += abs;
            ++counts[abs / intervallLength];
        }
        System.out.println("*******************");
        System.out.println("avg: " + (sum / t));
        System.out.println("avg: " + (sumAbs / t));
        long[] countsM = new long[counts.length];
        fill(countsM, (i) -> (long) i * intervallLength);
        ArrayPrinter.printArray(countsM, 5);
        ArrayPrinter.printArray(counts, 5);
    }

    public static int calculateRange(long[] input, long expected) {
        long[] minMax = calculateMinMax(input);
        return (int) Math.max(expected - minMax[0], minMax[1] - expected);
    }

    public static void printBinomialDistribution(int n, double p, int length) {
        InputGenerator generator = InputGenerator.createBinomial(n, p);
        long[] input = generator.generate(length);
        int offset = calculateRange(input, generator.expectedValue);
        printDistribution(input, generator, generator.expectedValue - offset, generator.expectedValue + offset);
    }

    public static void estimateOptimalSolutionCount(int m, int amountOfArrays) {
        long[] input = generateInput(7, 10000);
        int counter = 0;
        int stepSize = m / amountOfArrays;
        int next = stepSize;
        System.out.print("  0%");
        ProgressPrinter p = new ProgressPrinter(m, stepSize);
        int i;
        for (i = 0; i < m && !Thread.interrupted(); ++i) {
            if (!PartitionSolver.solveRLS(input, 0).isNotOptimal()) {
                ++counter;
            }
            if (i == next) {
                p.printProgressIfNecessary(i);
                next += stepSize;
                input = generateInput(7, 10000);
            }
        }
        p.printProgressIfNecessary(i);
        System.out.printf("%n%d out of %,d solutions were optimal", counter, i);
    }

    public static void testRandomBinomial(long m, int n) {
        System.out.println(testRandomBinomial(m, n, 1.0 / n));
    }

    public static long testRandomBinomial(long m, int n, double p) {
        long sum = 0;
        for (int i = 0; i < m; ++i) {
            sum += binomialK(n, p);
        }
        return Math.abs(Math.round(m * (n * p)) - sum);
    }

    public static void testRandomBinomialPartition(long m, long n, double p, long k) {
        printf("testRandomBinomialPartition(%,d, %,d, %.3f, %,d)%n", m, n, p, k);
        MinMaxAvgEvaluator evaluator = new MinMaxAvgEvaluator(false);
        MinMaxAvgEvaluator evalDif = new MinMaxAvgEvaluator(false);
        MinMaxAvgEvaluator evalSteps = new MinMaxAvgEvaluator(false);
        int countRLSN_fail = 0;
        int countDouble_fail = 0;
        long expected = Math.round(m * n * p);
        long[] input;
        long maxSteps = 100 * 1000;
        printf("Expected value; %,d%n", expected);
        printf("Max steps;      %,d%n", maxSteps);
//        setPrintToConsole(false);
        long[] failed_BitFlipAmountNecessary = new long[22];
        int changedBitMax = failed_BitFlipAmountNecessary.length - 1;
        long[] failed_ChangesNecessary = new long[22];
        int changedNeededMax = failed_ChangesNecessary.length - 1;
        int unsolvableCount = 0;
        int notUnsolvableCount = 0;
        for (int i = 0; i < k; ++i) {
            input = InputGenerator.binomialDistributed((int) m, (int) n, p);
            Solution sol = PartitionSolver.solveRLS_UniformNeighbour(input, maxSteps, 2);
//            Solution sol = PartitionSolver.solveEA(input, 100000, 3.0 / m);
            evaluator.insert(Math.abs(sol.getTotalSum().longValue() - expected));
            long dif = sol.getDif().longValue();
            if (dif != 0) {
                evalDif.insert(sol.getDif().longValue());
                if (PartitionSolver.solveEA(input, maxSteps, 3.0 / m).isNotOptimal()) {
                    ++countDouble_fail;
                } else {
                    ++countRLSN_fail;
                }

                // mainly for debugging
                if (dif > 0) {
                    /*
                    if (PartitionSolver.solveRLS_UniformNeighbour(input, 10 * maxSteps, 2, sol).isNotOptimal()) {
                        System.out.println("Seems unsolvable");
                        ++unsolvableCount;
                        printSeeminglyNotPossibleInput(input, sol, Math.round(n * p));
                    } else {
                        System.out.println("algo just did not have enough time");
                    }
                    /*/
                    long flippedBits = sol.getFlippedBits();
                    long changes = sol.getChanges();
                    if (PartitionSolver.solveEA(input, 10 * maxSteps, 3.0 / m, sol).isNotOptimal()) {
                        System.out.print("Seems unsolvable");
                        if (PartitionSolver.solveRLS_UniformNeighbour(input, maxSteps, 2).isNotOptimal()) {
                            println(" even with a restart -> " + Arrays.toString(input));
                            ++unsolvableCount;
                        } else {
                            println(" but a restart helps");
                            ++notUnsolvableCount;
                        }
                    } else {
                        flippedBits = sol.getFlippedBits() - flippedBits;
                        changes = sol.getChanges() - changes;
//                        System.out.printf("algo needed to flip %d bits in %d steps%n", flippedBits, changes);
                        ++failed_BitFlipAmountNecessary[(int) Math.min(flippedBits, changedBitMax)];
                        ++failed_ChangesNecessary[(int) Math.min(changes, changedNeededMax)];
                    }
                    //*/
                }
            } else {
                evalSteps.insert(sol.getTries());
            }
        }
        String[] temp = new String[]{"dif from expected val", "dif from opt (fail)", "steps count (success)"};
        int digits = Arrays.stream(temp).max(Comparator.comparingInt(String::length)).get().length();
        ArrayPrinter.printArray("desc : ", (i) -> temp[i], temp.length, digits);
        MinMaxAvgEvaluator.printMultipleNonNegative(digits, evaluator, evalDif, evalSteps);
        if (countRLSN_fail > 0) {
            printf("RLS-N(2) did not find a solution but EA-SM(3/n): %d%n", countRLSN_fail);
            if (Arrays.stream(failed_BitFlipAmountNecessary).sum() > 0) {
                digits = 4;
                ArrayPrinter.printArray("Bits that needed to be flipped when dif > 0: ", (i) -> i < changedBitMax ? String.valueOf(i) : changedBitMax + "+", failed_BitFlipAmountNecessary.length, digits);
                ArrayPrinter.printArray("                                      Count: ", failed_BitFlipAmountNecessary, digits);
                ArrayPrinter.printArray("Necessary amount of changes when dif > 0:    ", (i) -> i < changedNeededMax ? String.valueOf(i) : changedNeededMax + "+", failed_ChangesNecessary.length, digits);
                ArrayPrinter.printArray("                                      Count: ", failed_ChangesNecessary, digits);
            }
        }
        if (countDouble_fail > 0) {
            printf("both did not find a solution:                    %d%n", countRLSN_fail);
        }
        if (unsolvableCount + notUnsolvableCount > 0) {
            printf(" unsolvable  inputs: %,d%n", unsolvableCount);
            printf("\"unsolvable\" inputs: %,d%n", notUnsolvableCount);
        }
        setPrintToConsole(true);
    }

    private static void printSeeminglyNotPossibleInput(long[] input, Solution sol, long expected) {
        int range = calculateRange(input, expected);
        long[] amount0 = new long[2 * range + 1];
        long[] amount1 = new long[2 * range + 1];
        int offset = (int) expected - range;
        int[] partition = sol.getPartition();
        for (int i = 0; i < input.length; ++i) {
            if (partition[i] == 0) {
                amount0[(int) input[i] - offset]++;
            } else {
                amount1[(int) input[i] - offset]++;
            }
        }
        long[] values = new long[amount0.length];
        fill(values, (i) -> offset + i);
        ArrayPrinter.printArray(values, 4);
        ArrayPrinter.printArray(amount0, 4);
        ArrayPrinter.printArray(amount1, 4);
        for (int i = 0; i < values.length; ++i) {
            values[i] -= expected;
        }
        ArrayPrinter.printArray(values, 4);
    }

    private static int perfectPartitionCount(long[] input) {
        long sum = Arrays.stream(input).sum();
        long optimal = sum / 2 + sum % 2;
        int count = 0;
        long end = Math.round(Math.pow(2, input.length - 1));
        for (int i = 0; i < end; ++i) {
            long current = (i & 1) * input[1];
            for (int j = 2; j < input.length; ++j) {
                current += ((i >> (j - 1)) & 1) * input[j];
            }
            if (current == optimal) {
                ++count;
            }
        }
        return 2 * count;
    }

    public static void testBinomialSolutionCount(int count, int length, int n, double p) {
        MinMaxAvgEvaluator evaluator = new MinMaxAvgEvaluator(false);
        ProgressPrinter printer = new ProgressPrinter(count, 10);
        for (int i = 0; i < count; ++i) {
            evaluator.insert(perfectPartitionCount(InputGenerator.binomialDistributed(length, n, p)));
            printer.printProgressIfNecessary(i);
        }
        printer.clearProgressAndPrintElapsedTime();
        evaluator.printEvaluation();
        System.out.printf("total: %,d", Math.round(Math.pow(2, length)));
    }

    public static void testBinomialSolutionCount(int count, int[] lengths) {
        double[] ps = new double[]{0.1, 0.9};
        int[] ns = new int[]{10, 100, 1000, 10000};
        startFilePrinting(Printer.PATH_AUTO_GENERATED + "\\other\\" + Printer.getTodayAsString()
                + "-binomialPerfectPartitionCount.csv");
        for (double p : ps) {
            for (int n : ns) {
                n = (int) Math.round(n / p);
                printf("n: %,d%np: %.2f,%nE(X)=%.2f%n--------------%n", n, p, n*p);
                testBinomialSolutionCount(count, lengths, n, p);
                println("***************");
                if (Thread.interrupted()) {
                    stopWritingToFile();
                    return;
                }
            }
        }
        stopWritingToFile();
    }

    public static void testBinomialSolutionCount(int count, int[] lengths, int n, double p) {
        MinMaxAvgEvaluator[] evaluators = new MinMaxAvgEvaluator[lengths.length];
        fill(evaluators, (i) -> new MinMaxAvgEvaluator(false));
        long[] possibilities = fill(lengths.length, (i) -> Math.round(Math.pow(2, lengths[i])));
        long[] possibilitiesHalf = fill(lengths.length, (i) -> nChooseK(lengths[i], lengths[i] / 2));
        ProgressPrinter printer = new ProgressPrinter(count, 10);
        for (int i = 0; i < count; ++i) {
            for (int e = 0; e < lengths.length; ++e) {
                evaluators[e].insert(perfectPartitionCount(InputGenerator.binomialDistributed(lengths[e], n, p)));
            }
            printer.printProgressIfNecessary(i);
        }
        printer.clearProgressAndPrintElapsedTime();
        int digits = (int) getNeededDigits(possibilities, fill(evaluators.length, (i) -> evaluators[i].getSum()));
        ArrayPrinter.printArray("length:", cast(lengths), digits);
        MinMaxAvgEvaluator.printMultipleNonNegative(digits, evaluators);
        printArrayWithDecimalPoint("total: ", possibilities, digits);
        ArrayPrinter.printArray("total%:", fill(evaluators.length, (i) -> evaluators[i].getAvg()), possibilities, digits);
        printArrayWithDecimalPoint("half01:", possibilitiesHalf, digits);
        ArrayPrinter.printArray("half01%", fill(evaluators.length, (i) -> evaluators[i].getAvg()), possibilitiesHalf, digits);
    }
}
