For the geometric distribution once again a variant of the RLS performs the best.
The $pmut_{-3.25}$ performs almost equally good with only the (1+1) EA variant performing clearly worse.
Here the algorithms are sorted again by their average number of flips per steps. The theory of seems to be true for this kind of input.\newline
To further confirm the best choice for this kind of input there was another experiment of the best variants.
The setup is mostly the same except for having a fixed time limit of 100,000 instead of using $100 \cdot n\ln(n)$ as the limit.
The smaller inputs are harder relative to their input size so using $100 \cdot n\ln(n)$ as a bound is too small.
The first try was executed with 50,000 as the step limit but there the algorithms performed to bad for $n=20$.
Therefore for the second attempt the step limit was increased to 100,000.
The first table lists the number of runs where the different algorithms did not find the optimal solution within the time limit.

\begin{tabular}{cccccccc}

      input size    & 20  & 50  & 100 & 500 & 1000 & 5000 & 10000 \\\hline
      RLS           & 983 & 951 & 885 & 619 & 425  & 42   & 0     \\
      RLS-R (2)      & 881 & 578 & 171 & 0   & 0    & 0    & 0     \\
      (1+1) EA (1/n) & 464 & 132 & 48  & 1   & 1    & 0    & 0     \\
      (1+1) EA (2/n) & 149 & 11  & 1   & 0   & 0    & 0    & 0     \\
      pmut(-3.25)   & 284 & 67  & 27  & 0   & 0    & 0    & 0     \\
      pmut(-3.5)    & 312 & 91  & 38  & 0   & 1    & 0    & 0     \\
\end{tabular}

For small inputs the geometric distributed input seems to be likely to not have a perfect partition or only very few because there were many iterations where neither of the algorithms found an optimal solution within the time limit.
It seems many of the algorithms especially the variants of the RLS seem to be likely to get stuck in a local optima.
The (1+1) finds an optimum in most of the runs, so the geometric distributed inputs also seem to be likely to have a perfect partition for small values.
They are definitely not as solvable as the binomial inputs but they still have a perfect partition most times.
The next table visualises the average number of iterations the algorithm needed for finding an optimal solution if the algorithm managed to do so.

\begin{tabular}{cccccccc}
      input size    & 20    & 50    & 100   & 500  & 1000 & 5000 & 10000 \\\hline
      RLS           & 35    & 78    & 140   & 566  & 904  & 2119 & 2188  \\
      RLS-R (2)      & 357   & 2024  & 5369  & 4687 & 3945 & 2752 & 2583  \\
      (1+1) EA (1/n) & 21827 & 20775 & 14583 & 9459 & 7702 & 4358 & 3924  \\
      (1+1) EA (2/n) & 18211 & 11613 & 7529  & 5266 & 4359 & 3858 & 3293  \\
      pmut(-3.25)   & 22530 & 16421 & 11312 & 5909 & 5375 & 2843 & 2246  \\
      pmut(-3.5)    & 24202 & 17414 & 11731 & 6503 & 5216 & 2773 & 2388  \\
\end{tabular}

The variants of the (1+1) EA and of the $pmut$ algorithm seem to take about 20,000 iterations for $n=20$ if they manage to find the optimal solution.
They also perform better and better the lager the input gets.
This is probability caused by the many additional small values that can be used for smaller adjustments to the fitness.
Also a really high value does not have as much of an input, because there are possibly other larger values which cancel each other out, if they are in different bins.
The last table again lists the total average number of steps.

\begin{tabular}{cccccccc}
      input size    & 20    & 50    & 100   & 500   & 1000  & 5000 & 10000 \\\hline
      RLS           & 98300 & 95103 & 88516 & 62115 & 43019 & 6230 & 2188  \\
      RLS-R (2)      & 88142 & 58654 & 21551 & 4687  & 3945  & 2752 & 2583  \\
      (1+1) EA (1/n) & 58099 & 31232 & 18683 & 9550  & 7795  & 4358 & 3924  \\
      (1+1) EA (2/n) & 30397 & 12585 & 7622  & 5266  & 4359  & 3858 & 3293  \\
      pmut(-3.25)   & 44531 & 22021 & 13707 & 5909  & 5375  & 2843 & 2246  \\
      pmut(-3.5)    & 47851 & 24929 & 15086 & 6503  & 5311  & 2773 & 2388  \\
\end{tabular}

The RLS is only an option if the input is large enough $n \ge 10,000$. For smaller input sizes especially for $n \le 100$ choosing the (1+1) EA with mutation rate $2/n$ seems like the best choice. For larger values this (1+1) EA does not find an optimal solution the fastest but is still fast enough to be a viable option. Another rather save option is $pmut_-3.25$. This algorithm performs worse for $n \le 100$ but is still good in comparison to the other algorithms. For $n \ge 1000 \space pmut_-3.25$ start to outperform the best version of the (1+1) EA and almost all other researched algorithms.